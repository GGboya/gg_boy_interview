# 知乎golang后端面经汇总


## 一、Redis

### 1、加一层redis缓存, redis缓存会出现什么问题  *2

在应用程序中加入Redis缓存可以提高程序的性能和响应速度，但是也可能会出现以下问题：

1. 缓存一致性问题：当缓存和数据库数据不一致时，可能会导致数据错误或者应用程序出现异常。这种问题可以通过使用缓存更新策略、缓存失效时间等方式进行解决。
2. 缓存雪崩问题：当大量的缓存同时失效时，可能会导致大量的请求同时涌入数据库，从而导致数据库负载过高，甚至崩溃。这种问题可以通过设置缓存失效时间的随机化、多级缓存等方式进行解决。
3. 缓存穿透问题：当大量不存在的数据被请求时，会导致大量的请求直接访问数据库，从而导致数据库负载过高。这种问题可以通过使用布隆过滤器等方式进行解决。
4. 缓存击穿问题：当一个缓存key被大量请求同时访问，从而导致该key对应的数据被频繁从数据库中加载，从而导致数据库负载过高。这种问题可以通过使用互斥锁等方式进行解决。
5. Redis性能问题：当缓存数据量过大或者并发量过高时，可能会导致Redis性能下降或者崩溃。这种问题可以通过水平扩展、优化Redis配置等方式进行解决。

总之，在使用Redis缓存时需要注意缓存一致性、缓存失效策略、缓存容量、缓存并发等问题，合理的配置和使用Redis可以有效地提高应用程序的性能和可靠性。

### 2、Redis的常用数据结构，string类型的底层怎么实现的？

（1）字符串

（2）哈希表

（3）集合

（4）列表

（5）有序集合

在Redis中，string类型的底层实现是使用了简单动态字符串（SDS）的数据结构。简单动态字符串是Redis自己实现的一种字符串类型，它是一个可动态调整长度的字符数组，能够自动扩展和收缩。简单动态字符串的底层实现使用了C语言中的指针和内存动态分配等机制。

简单动态字符串的优点是可以动态调整字符串的长度，同时还具有一些安全性和效率上的优势。由于字符串的长度可以动态变化，因此可以避免浪费内存空间。而且，简单动态字符串的内存管理由Redis自己负责，可以有效地防止缓冲区溢出等安全问题。

### 3、Redis分布式锁怎么实现的？

Redis分布式锁的实现方式主要有以下两种：

1. 基于SETNX实现

使用Redis的SETNX命令可以实现分布式锁，具体实现方法如下：

- 当一个客户端需要获取锁时，它会调用SETNX命令尝试将一个特定的键值对写入Redis。
- 如果这个键不存在，那么SETNX命令将会创建这个键，并将值设置为“1”，表示获取锁成功。
- 如果这个键已经存在，那么SETNX命令将会返回“0”，表示获取锁失败。
- 当客户端执行完任务需要释放锁时，它将会调用DEL命令删除这个键，释放锁。

这种方法的缺点是没有设置过期时间，如果获取锁的客户端崩溃或者在执行任务时出现故障，那么其他客户端将永远无法获取到这个锁。因此，需要设置一个适当的超时时间来保证锁的可靠性。

1. 基于RedLock算法实现

RedLock是一种基于多个Redis节点实现的分布式锁算法，它可以避免单点故障和网络问题导致的锁失效问题。具体实现方法如下：

- 首先，获取当前时间戳，并根据某种算法计算出一个随机字符串，作为锁的值。
- 然后，使用SETNX命令在多个Redis节点上尝试获取锁。
- 如果在大多数节点上获取锁成功，那么就认为获取锁成功。
- 在执行完任务后，客户端需要在所有节点上释放锁。

由于使用了多个Redis节点，RedLock算法比单个Redis节点的实现更加可靠，但同时也更加复杂。实际上，Redis官方并不推荐使用RedLock算法来实现分布式锁，因为它依赖于网络延迟和时钟同步，容易出现各种问题。建议使用基于SETNX的简单实现方式，并设置适当的过期时间来保证锁的可靠性。

### 4、项目中保证缓存一致性。

在项目中保证缓存一致性，可以考虑以下几个方面：

1. 缓存更新机制：当数据发生变化时，需要及时更新缓存中的数据，保证缓存数据与数据库中的数据一致。可以使用定时任务、消息队列等机制，定期更新缓存数据。
2. 缓存失效机制：缓存中的数据需要有一定的失效机制，避免缓存中的数据过期而导致数据不一致的问题。可以设置缓存数据的过期时间，当缓存数据过期时，需要重新从数据库中读取数据，并更新缓存中的数据。
3. 缓存穿透机制：当查询的数据在数据库中不存在时，需要考虑缓存穿透的问题，避免大量无效的数据库查询请求打到数据库上。可以使用布隆过滤器等机制，过滤掉不存在的数据。
4. 缓存雪崩机制：当缓存中的大量数据同时失效时，可能会导致大量的数据库请求，使得数据库压力骤增，造成系统崩溃的问题。可以设置缓存的过期时间随机化，避免缓存同时失效。
5. 多级缓存机制：可以使用多级缓存机制，将缓存分为本地缓存、分布式缓存等多个级别。本地缓存可以提高缓存访问速度，分布式缓存可以保证缓存数据的可靠性和高可用性。

### 5、redis缓存问题，key过期了怎么办，为什么redis能O(1)

当一个key在Redis中过期时，Redis会在内部自动删除该key，这样就可以释放出对应的内存空间。当客户端请求过期的key时，Redis将返回“key不存在”的响应，从而保证数据的一致性和正确性。

Redis使用了一种称为“惰性删除”的机制。当一个key过期时，Redis不会立即删除它，而是将其放入一个专门的过期key列表中，并在后台以一定的时间间隔定期地扫描该列表，并删除已经过期的key。这样可以避免在每次key过期时立即删除对性能造成的影响。

Redis能够在O(1)的时间复杂度内进行读写操作的主要原因是它将所有的数据都存储在内存中，并且采用了一些高效的数据结构来存储和管理这些数据。

Redis中使用的主要数据结构包括哈希表、有序集合、跳跃表等，这些数据结构都具有高效的查找、插入、删除等操作。例如，哈希表的平均查找时间复杂度是O(1)，有序集合的插入、删除、查找操作的时间复杂度都是O(log n)，跳跃表的查询和插入的时间复杂度也是O(log n)。这些高效的数据结构使得Redis可以在O(1)的时间复杂度内处理大量的读写请求，从而实现高性能和高吞吐量。

另外，Redis还采用了多路复用技术来实现高并发的网络请求处理。它通过监听一个或多个网络端口，使用异步IO来处理请求，并采用事件驱动的方式来处理网络请求。这种设计可以有效地避免了线程切换和上下文切换的开销，从而提高了Redis的性能和并发能力。





### 



## 二、语言基础

### 1、GMP模型？  *2

一定要认认真真的把GMP搞懂！

### 2、说下Go的GC模型 *2

#### 1. 垃圾回收

**垃圾回收、三色标记原理**

垃圾回收就是对程序中不再使用的内存资源进行自动回收的操作。

##### 1.1 常见的垃圾回收算法：

- 引用计数：每个对象维护一个引用计数，当被引用对象被创建或被赋值给其他对象时引用计数自动加 +1；如果这个对象被销毁，则计数 -1 ，当计数为 0 时，回收该对象。
  - 优点：对象可以很快被回收，不会出现内存耗尽或到达阀值才回收。
  - 缺点：不能很好的处理循环引用
- 标记-清除：从根变量开始遍历所有引用的对象，引用的对象标记“被引用”，没有被标记的则进行回收。
  - 优点：解决了引用计数的缺点。
  - 缺点：需要 STW（stop the world），暂时停止程序运行。
- 分代收集：按照对象生命周期长短划分不同的代空间，生命周期长的放入老年代，短的放入新生代，不同代有不同的回收算法和回收频率。
  - 优点：回收性能好
  - 缺点：算法复杂

##### 1.2 三色标记法

- 初始状态下所有对象都是白色的。
- 从根节点开始遍历所有对象，把遍历到的对象变成灰色对象
- 遍历灰色对象，将灰色对象引用的对象也变成灰色对象，然后将遍历过的灰色对象变成黑色对象。
- 循环步骤3，直到灰色对象全部变黑色。
- 通过写屏障(write-barrier)检测对象有变化，重复以上操作
- 收集所有白色对象（垃圾）。

##### 1.3 STW（Stop The World）

- 为了避免在 GC 的过程中，对象之间的引用关系发生新的变更，使得GC的结果发生错误（如GC过程中新增了一个引用，但是由于未扫描到该引用导致将被引用的对象清除了），停止所有正在运行的协程。
- STW对性能有一些影响，Golang目前已经可以做到1ms以下的STW。

##### 1.4 写屏障(Write Barrier)

- 为了避免GC的过程中新修改的引用关系到GC的结果发生错误，我们需要进行STW。但是STW会影响程序的性能，所以我们要通过写屏障技术尽可能地缩短STW的时间。

造成引用对象丢失的条件:

一个黑色的节点A新增了指向白色节点C的引用，并且白色节点C没有除了A之外的其他灰色节点的引用，或者存在但是在GC过程中被删除了。以上两个条件需要同时满足：满足条件1时说明节点A已扫描完毕，A指向C的引用无法再被扫描到；满足条件2时说明白色节点C无其他灰色节点的引用了，即扫描结束后会被忽略 。

写屏障破坏两个条件其一即可

- 破坏条件1：Dijistra写屏障

满足强三色不变性：黑色节点不允许引用白色节点 当黑色节点新增了白色节点的引用时，将对应的白色节点改为灰色

- 破坏条件2：Yuasa写屏障

满足弱三色不变性：黑色节点允许引用白色节点，但是该白色节点有其他灰色节点间接的引用（确保不会被遗漏） 当白色节点被删除了一个引用时，悲观地认为它一定会被一个黑色节点新增引用，所以将它置为灰色



### 3、golang怎么体现面向对象思想的？

Go语言在设计时并没有完全采用传统的面向对象编程思想，而是倾向于以“结构体”（struct）和“接口”（interface）的方式来实现面向对象的思想。下面是Go语言如何体现面向对象思想的一些特点：

1. 结构体和方法：Go语言中可以通过定义结构体来表示一个对象，结构体可以包含数据属性和方法，方法可以被绑定到结构体上，从而实现面向对象编程中的封装和抽象。例如，下面是一个包含属性和方法的结构体定义：

```go
goCopy codetype Person struct {
    name string
    age int
}

func (p *Person) SayHello() {
    fmt.Printf("Hello, my name is %s and I'm %d years old.\n", p.name, p.age)
}
```

1. 接口：Go语言中的接口定义了一组方法的集合，如果一个对象实现了接口中定义的所有方法，那么它就实现了该接口。通过接口，我们可以实现多态性和依赖倒置原则等面向对象的特性。例如，下面是一个接口定义：

```go
scssCopy codetype Animal interface {
    Eat(food string)
    Sleep()
}
```

1. 继承和多态：Go语言中没有像其他语言那样的显式继承关系，但是我们可以通过匿名字段（anonymous field）的方式来实现继承和多态性。匿名字段可以让一个结构体类型包含另一个结构体类型的所有属性和方法，并且可以直接调用这些属性和方法。例如，下面是一个实现继承和多态的例子：

```go
goCopy codetype Animal struct {
    name string
}

func (a *Animal) Eat(food string) {
    fmt.Printf("%s is eating %s\n", a.name, food)
}

type Dog struct {
    Animal
}

func (d *Dog) Sleep() {
    fmt.Printf("%s is sleeping\n", d.name)
}

func main() {
    dog := &Dog{Animal{"Tom"}}
    dog.Eat("meat")
    dog.Sleep()
}
```

总的来说，尽管Go语言并没有像其他面向对象编程语言那样完全采用传统的面向对象编程思想，但是通过结构体和接口的方式，它仍然能够实现面向对象编程的核心特性，例如封装、继承、多态和依赖倒置等。



### 4、Golang的有哪些比较突出的特点？

Go语言是一门静态类型的编程语言，它在设计时注重简洁、高效和安全，具有许多突出的特点，以下是其中一些：

1. 并发编程：Go语言原生支持协程（goroutine）和通道（channel），这是其并发编程能力的核心。开发者可以轻松地使用协程和通道来编写高效且线程安全的程序，从而提高程序的性能和可维护性。
2. 高效编译：Go语言的编译速度非常快，编译器可以在数秒内将大型程序编译成可执行文件。此外，Go语言还提供了垃圾回收机制，可以自动管理内存，减轻了开发者的负担。
3. 简洁易学：Go语言的语法设计简洁明了，代码易于理解和维护。其语言规范只有几十页，学习起来非常容易。
4. 跨平台支持：Go语言可以在多个操作系统和处理器架构上运行，包括Linux、Windows、macOS、ARM和x86等。
5. 强大的标准库：Go语言的标准库提供了许多常用的功能，如HTTP服务器、JSON编解码、加密、网络通信等，这些库都经过高度优化，可以在性能和安全方面提供很好的保证。
6. 静态类型检查：Go语言是一门静态类型的编程语言，编译器可以在编译时检查类型错误，提高了代码的稳定性和可靠性。

总的来说，Go语言在并发编程、编译速度、简洁易学、跨平台支持、强大的标准库和静态类型检查等方面具有许多突出的特点，这些特点使得Go语言在Web开发、云计算、网络编程和大数据处理等领域得到了广泛的应用。

### 5、Goroutine是什么？相比于java中线程或者是OS级别的线程有什么区别？

Goroutine是Go语言中一种轻量级的线程实现，与操作系统线程（OS Thread）或Java线程相比，它们有以下几个主要区别：

1. 轻量级：Goroutine比操作系统线程更轻量，一般只占用2KB的栈内存，创建和销毁的开销较小，因此可以创建大量的Goroutine，支持高并发的编程模型。
2. 多路复用：Goroutine可以在一个OS线程中并发执行多个任务，这是通过Go语言提供的调度器实现的。调度器可以将多个Goroutine映射到一个或多个OS线程中，实现高效的任务调度。
3. 通道通信：Goroutine之间通过通道进行通信，而不是共享内存，这样可以避免并发访问共享变量时的竞争和死锁等问题，提高程序的健壮性和可维护性。
4. 语言级别支持：Goroutine是Go语言的一部分，它们的创建和管理是由编译器和运行时系统提供支持的，因此使用起来非常方便。



### 6、Go指令的调度流程是什么样的？

Go语言中的指令调度（Instruction Scheduling）是由Go语言运行时系统的调度器（Scheduler）来管理的，其大致流程如下：

1. 当程序启动时，调度器会创建一个或多个系统线程（System Thread），称为P（Processor）。
2. 当需要执行一个Goroutine时，调度器会将其放入一个全局的调度队列（Global Run Queue）中。
3. 调度器会选择一个空闲的P，将其与一个或多个Goroutine关联起来，形成一个执行上下文（Execution Context）。
4. 执行上下文包含一个本地的调度队列（Local Run Queue），其中存放着P关联的Goroutine。
5. 当当前的Goroutine发生阻塞时，调度器会将其从本地队列中移除，然后重新选择一个Goroutine执行。
6. 如果本地队列为空，调度器会尝试从全局队列中获取Goroutine执行，如果全局队列也为空，调度器会尝试从其他P的本地队列中窃取Goroutine执行。
7. 当Goroutine执行完成时，调度器会将其从P的本地队列中移除，然后将P恢复为空闲状态。

通过这种调度流程，Go语言能够实现高效的任务调度和负载均衡，避免了传统线程模型中因为线程过多导致的资源浪费和竞争问题。





### 7、Map是并发安全的吗？ 

不安全

### 8、 那你要是想让它并发安全应该怎么做？

加锁，用sync.map

### 9、sync包有了解吗？

是的，sync包是Go语言标准库中的一个包，提供了一些基本的同步原语，用于实现并发程序的同步和通信。sync包包含以下主要类型和函数：

1. 互斥锁（Mutex）：用于实现互斥访问共享资源。使用Mutex可以确保在同一时间只有一个goroutine可以访问共享资源。sync.Mutex类型提供了两个主要方法：Lock和Unlock。
2. 读写锁（RWMutex）：用于实现多读单写的并发访问。使用RWMutex可以提高共享资源的并发读取性能。sync.RWMutex类型提供了四个主要方法：RLock、RUnlock、Lock和Unlock。
3. 条件变量（Cond）：用于在goroutine之间进行通信和同步。sync.Cond类型提供了三个主要方法：Wait、Signal和Broadcast。
4. 原子操作（atomic）：用于实现原子操作，例如对于变量的增加或减少。sync/atomic包提供了一组原子操作函数，例如AddInt32、CompareAndSwapInt32等。

sync包中还有其他类型和函数，例如Once、Map、WaitGroup等，它们提供了更高级的同步和并发控制功能。

总之，sync包是Go语言中用于实现同步和通信的重要工具包，它提供了一些基本的同步原语和高级同步工具，可以帮助开发人员编写更加高效和可靠的并发程序。

### 10、map扩容

在Golang中，map是一种非常常用的数据结构，用于存储键值对。当往map中插入新的键值对时，如果map中的元素已经达到了其容量限制，就需要进行扩容操作。

Golang中的map是使用哈希表实现的，哈希表在扩容时需要进行以下步骤：

1. 创建一个新的底层数组，其大小为原有底层数组大小的两倍。
2. 遍历原有底层数组，将其中的每个键值对重新计算哈希值，并将其插入到新的底层数组中。
3. 释放原有底层数组的内存空间。

在进行上述操作时，Golang的map使用了一种称为“增量式哈希表扩容”的策略，即每次扩容只增加一部分元素，而不是一次性将所有元素全部复制到新的底层数组中。这种策略能够减小内存占用和减少扩容时的时间复杂度。

需要注意的是，由于Golang的map是无序的，因此在进行扩容时可能会改变键值对的存储顺序。因此，在使用map时应该尽量避免依赖于键值对的存储顺序。

### 11、Channel了解吗？

在Golang中，Channel是一种通信机制，用于协调多个goroutine之间的交互操作。Channel可以让goroutine之间通过发送和接收消息来进行同步和数据传递，从而实现高效且安全的并发编程。

Channel的使用非常简单，只需要使用make函数创建一个Channel，并使用<-符号来发送和接收数据，如下所示：

```go
goCopy codech := make(chan int) // 创建一个int类型的Channel

go func() {
    ch <- 42 // 向Channel中发送数据
}()

val := <-ch // 从Channel中接收数据
```

在上面的示例中，我们创建了一个int类型的Channel，然后启动了一个goroutine来向Channel中发送数据。接着，在主goroutine中使用<-操作符从Channel中接收数据，并将其赋值给val变量。

需要注意的是，Channel是一种阻塞机制，即发送和接收操作都会阻塞当前goroutine，直到有另一个goroutine进行对应的发送或接收操作。这种阻塞机制可以帮助我们避免竞态条件和数据竞争等并发编程中常见的问题。

此外，Golang的Channel还支持缓冲，即可以设置Channel的容量，允许在Channel中缓存一定数量的元素，从而减少阻塞操作的发生次数。但是需要注意，缓冲的Channel并不一定比非缓冲的Channel性能更好，具体取决于具体的使用场景和实现方式。

### 12、Go的捕获迭代变量有了解吗？

这是在学习 Go 程序设计 中遇到的一个比较重要的一个警告。这是个 Go 语言的词法作用域规则的陷阱。看完之后感觉是真的一个比较让人疑惑困惑的地方。所以特地记录一下。由标题就可以知道了，迭代变量，肯定是在 for 中遇到的问题。来看一个简单的例子说明一下这个问题所在。

看一段简单的代码， 首先是错误的示例：



```go
var slice []func()

func main() {
    sli := []int{1, 2, 3, 4, 5}
    for _, v := range sli {
        fmt.Println(&v)
        slice = append(slice, func(){
            fmt.Println(v * v) // 直接打印结果
        })
    }
    for _, val  := range slice {
        val()
    }
}
// 输出 25 25 25 25 25
```


你可能会很奇怪为什么会出现这种情况，结果不应该是 1, 4, 9, 16, 25 吗？其实原因是循环变量的作用域的规则限制。在上面的程序中，v 在 for 循环引进的一个块作用域内进行声明。在循环里创建的所有函数变量共享相同的变量，就是一个可访问的存储位置，而不是固定的值。(你会惊奇的发现 &v 的内存地址是一样的)

模拟一下实际的情况，假设 v 变量的地址在 0x12345678 上， for 循环在迭代过程中，所有变量值都是在这地址上迭代的。当最后调用匿名函数的时候，取值也是在这块地址上。所以最后输出的结果都是迭代的最后一个值。至少在 Go 语言中是不用质疑的。这里也是一个陷阱，如果你不清楚的话，肯定会遇到坑。那个该如何修改呢？



```go
var slice []func()

func main() {
    sli := []int{1, 2, 3, 4, 5}
    for _, v := range sli {
        temp := v // 其实很简单 引入一个临时局部变量就可以了，这样就可以将每次的值存储到该变量地址上
        fmt.Println(&temp) // 这里内存地址是不同的
        slice = append(slice, func(){
            fmt.Println(temp *  temp) // 直接打印结果
        })
    }
    for _, val  := range slice {
        val()
    }
}
    // 输出 1, 4, 9, 16, 25 预期结果
```


只需要引入一个局部变量便可以解决了，这是必须的。否则你的程序将不会有可预期的结果。



### 13、Go的context有了解吗？

Context 是Go 语言独有功能之一，用于上下文控制，可以在 goroutine 中进行传递。

context 与 select-case 联合，还可以实现上下文的截止时间、信号控制、信息传递等跨 goroutine 的操作，是 Go 语言协程的重要组成部分。

详细学习[csdn，深入了解context]([(27条消息) go context详解_go语言context_牛奔的博客-CSDN博客](https://blog.csdn.net/Guzarish/article/details/119627758))



### 14、了解go的内存泄露吗?

Go语言是一门自动内存管理的语言，它内置的垃圾回收机制可以自动管理程序的内存。但是，即使使用了垃圾回收机制，Go语言程序也可能会出现内存泄漏的问题，导致程序内存占用过高、性能下降、甚至崩溃等问题。

在Go语言中，内存泄漏通常是由以下几个原因引起的：

1. 指针问题：当程序中存在未释放的指针或者指针引用关系不正确时，会导致内存泄漏。
2. 长期持有引用：当程序中持有大量的长期引用对象时，会导致内存泄漏。
3. 资源未释放：当程序中使用了一些需要手动释放资源的对象，但是程序未正确释放这些资源时，会导致内存泄漏。
4. 无限制增长的数据结构：当程序中存在无限制增长的数据结构时，会导致内存泄漏。

为了避免Go语言中的内存泄漏问题，可以采取以下措施：

1. 使用 defer 关键字释放资源：在函数执行结束时，使用 defer 关键字释放资源可以保证资源的正确释放。
2. 使用内置的 runtime/debug 包：该包中提供了一些内存分析和调试的工具，可以帮助我们分析和定位内存泄漏问题。
3. 使用专业的工具进行内存分析：例如，可以使用 Go pprof 工具对程序进行性能分析和内存分析，帮助我们定位和解决内存泄漏问题。
4. 合理的设计数据结构和算法：合理的设计数据结构和算法可以避免程序中出现无限制增长的数据结构，从而避免内存泄漏问题。

总之，Go语言虽然内置了垃圾回收机制，但是仍然需要程序员进行合理的内存管理，避免出现内存泄漏问题。

### 15、slice和array的区别, 顺便说了一嘴扩容规则

在Go语言中，数组和切片是两种常用的数据类型，它们有以下的区别：

1. 数组是一种定长的数据结构，需要在定义时指定长度；切片则是一种动态可变的数据结构，长度可以随时增加或减少。
2. 数组的元素类型和长度都是固定的，而切片的元素类型和长度都是可变的。
3. 数组在传递时会被完整地复制，而切片则是通过引用来传递的。

### 16、输出下面代码结果

1. ```go
   func ap(a []int) {
       a = append(a, 10)
   }
   
   func app(a []int) {
       a[0] = 1
   }
   
   func main() {
       a := []int{7,8,9}
       fmt.Println(a) // ?
       ap(a)
       fmt.Println(a) // ?     
       app(a) 
       fmt.Println(a) // ?     
   }
   ```

   答案：

   7 8 9 

   7 8 9    扩容了，指针变化了，所以还是789

   1 8 9     修改了指针所指向得底层数组得元素，因此变了

   

### 17、问下面的代码有什么问题?

```go
type Book struct {
    Name    string
    Authors []string `json:"authors"`
}

func main() {
    book := Book{}
    s := `{"name":"foo","authors":"bar,ten"}`
    err := json.Unmarshal([]byte(s), &book)
    fmt.Println(book, err)
}
```

答案：

Authors字段的类型不匹配， 照代码中的定义，Authors字段的类型是[]string，而在JSON字符串中，该字段的值是一个字符串，因此无法将字符串直接解析为字符串切片。

```go
type Book struct {
    Name    string
    Authors []string `json:"authors"`
}

func main() {
    book := Book{}
    s := `{"name":"foo","authors":["bar","ten"]}`
    err := json.Unmarshal([]byte(s), &book)
    fmt.Println(book, err)
}

```





## 三、Docker

### 1、Docker容器化是什么？怎么自定义一个镜像上传？dockerfile和compose容器编排了解过吗？

Docker容器化是一种虚拟化技术，它通过在主机操作系统上运行的容器中隔离应用程序和其依赖项，使应用程序可以在不同的环境中运行，而无需重新配置应用程序和环境。

要自定义一个Docker镜像并上传到Docker Hub或其他容器注册表，您需要使用Dockerfile。 Dockerfile是一个文本文件，其中包含指令来构建Docker镜像。您可以使用Dockerfile定义应用程序的依赖项、环境变量、文件和目录结构、命令等。使用Docker命令构建Dockerfile，生成一个镜像文件，然后可以上传到Docker Hub或其他容器注册表。

Docker Compose是一个用于定义和运行多个Docker容器的应用程序的工具，它使用一个YAML文件来配置应用程序中的容器，从而使容器之间的通信、依赖关系和其他配置更加简单和可管理。

使用Docker Compose进行容器编排的主要步骤如下：

1. 定义Docker Compose文件：创建一个YAML文件，用于定义应用程序中的所有容器及其相关配置，包括镜像、环境变量、端口映射、依赖关系等。您可以使用Docker Compose的命令来创建一个空白的Docker Compose文件。
2. 构建镜像：如果需要，可以使用Dockerfile构建自定义镜像，然后在Docker Compose文件中使用这些镜像。
3. 启动容器：使用Docker Compose的命令启动所有容器。Docker Compose会自动拉取镜像并启动容器，并根据定义的依赖关系确定启动顺序。
4. 查看容器状态：使用Docker Compose的命令查看所有容器的状态，包括正在运行的容器、已停止的容器和错误容器。
5. 停止容器：使用Docker Compose的命令停止所有容器。
6. 清理容器：使用Docker Compose的命令清理所有容器、网络和卷。

总之，Docker Compose简化了多个容器的管理和部署，为开发人员提供了一个可靠、一致和可重复的开发环境。





## 四、MySQL

### 1、隔离级别 *2

1. 读未提交（Read Uncommitted）：最低的隔离级别，允许一个事务读取另一个事务尚未提交的数据。这种隔离级别可能导致脏读（Dirty Read）和不可重复读（Non-Repeatable Read）。
2. 读已提交（Read Committed）：在这个隔离级别下，一个事务只能读取已经提交的数据。这种隔离级别可以防止脏读，但是可能会导致不可重复读。
3. 可重复读（Repeatable Read）：在这个隔离级别下，一个事务在执行期间可以多次读取同一行数据，而不受其他事务的影响。这种隔离级别可以防止不可重复读，但是可能会导致幻读（Phantom Read）。
4. 串行化（Serializable）：最高的隔离级别，保证了事务之间的完全隔离，使得每个事务之间都像是在串行执行一样。这种隔离级别可以防止脏读、不可重复读和幻读，但是可能会导致性能问题，因为事务只能按照顺序执行。

### 2、事务的四个特性

事务的四个特性通常被称为 ACID 特性，其中 ACID 代表原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。

1. 原子性：事务被视为一个原子操作，即要么全部成功执行，要么全部失败回滚。在事务执行期间，如果发生错误或异常，那么所有已执行的操作将被撤销，数据库会恢复到事务开始时的状态。

2. 一致性：事务在执行前和执行后，数据库必须处于一致状态。这意味着，当一个事务开始时，数据库中的所有约束都必须得到满足，而当事务结束时，所有约束也必须得到满足。

3. 隔离性：多个事务并发执行时，每个事务都应该被隔离开来，不能相互影响。也就是说，每个事务必须像独立的操作一样执行，其结果与其他事务的执行结果无关。

4. 持久性：事务一旦提交，其结果应该是永久性的，即使在系统发生故障的情况下也应该如此。事务的结果应该能够在任何情况下恢复，并且不应该被丢失或者临时的。

   

### 3、有用过列数据库吗？列数据库的优点

列数据库是一种特殊类型的数据库，其中数据存储在列中而不是行中。与行数据库（如传统的关系型数据库）不同，列数据库更加适合存储大量的、结构化的数据，并且具有以下优点：

1. 读取效率高：由于列数据库存储数据的方式，它可以更快地处理大量的数据。列数据库只读取需要的列，而不是整行，这使得查询变得更加快速和高效。
2. 执行分析性查询更快：列数据库可以更好地处理分析性查询，因为它可以很容易地搜索、过滤和汇总大量数据。
3. 易于扩展：列数据库具有良好的扩展性，可以轻松地添加更多的列或分区，并且可以分布式地处理海量数据。
4. 空间利用率高：列数据库通常具有更高的空间利用率，因为它只存储需要的列，而不是整行。这意味着在存储大量数据时可以节省存储空间。

总的来说，列数据库适用于存储和分析大量的、结构化的数据，能够提供更高的性能和更好的扩展性。

1. 

### 4、说下悲观锁和乐观锁的区别吧

1. 悲观锁：

悲观锁认为并发访问的数据很可能会被其他事务修改，因此在读取数据之前会加上锁，以防止其他事务对数据进行修改。悲观锁会对数据进行加锁，以保证在当前事务执行期间，其他事务无法对数据进行修改。这样做的好处是能够确保数据的一致性和完整性，但是会影响并发性能，因为多个事务需要等待锁的释放才能进行操作。

1. 乐观锁：

乐观锁认为并发访问的数据不太可能会被其他事务修改，因此在读取数据之后并不会加锁，而是在提交数据之前检查数据是否被其他事务修改过。如果数据没有被修改，则提交操作成功；如果数据被修改，则提交操作失败，需要重新执行。乐观锁不会对数据进行加锁，因此不会对并发性能产生影响，但是需要对数据进行额外的版本控制，以便检查数据是否被修改。

### 5、MySQL底层索引结构

B+树索引，哈希索引，全文索引

### 6、B+树的时间复杂度？

logn

### 7、B树和B+树的区别？

1. B树的每个节点都可以存储数据记录，而非叶子节点也可能存储数据。

   B+树的非叶子节点只存储指向子节点的指针，不存储数据记录，而数据记录只存储在叶子节点中。

2. B树的叶子节点没有指向其他节点的指针，因此叶子节点之间是相互独立的

   B+树的叶子节点之间通过链表相连，形成一个有序序列。

3. B+树相对于B树的优点是，由于叶子节点只存储数据记录，因此可以容纳更多的叶子节点，从而可以存储更多的数据记录，减少磁盘访问次数。同时，B+树的叶子节点之间通过链表相连，可以实现范围查询和顺序遍历等操作。因此，在实际应用中，B+树更为常用。

### 8、MySQL读一次数据的基础单位有了解吗？是一次IO不是一条数据

MySQL读一次数据的基础单位是一页（Page），也称为块（Block）。一页的大小通常是16KB，是MySQL进行磁盘IO的最小单位。

在MySQL中，数据通常存储在磁盘上的表空间（tablespace）中，表空间由若干个数据文件（data file）组成，每个数据文件由若干个页面组成。当MySQL需要读取一个数据块时，它会将该数据块从磁盘中读入到内存缓存中，然后对内存缓存中的数据进行操作，最后将修改的数据写回磁盘。

因为每次磁盘IO操作的代价很高，所以MySQL通常会尽可能地减少磁盘IO的次数，提高数据的访问效率。常用的优化手段包括合理设计索引、缓存常用数据、调整查询语句等。



### 9、mysql索引

MySQL索引的主要作用是提高查询的效率，尤其是当表中数据量很大时。通过使用索引，MySQL可以避免全表扫描，提高查询的速度。常见的索引类型包括主键索引、唯一索引、普通索引、全文索引等。

在使用MySQL索引时，需要注意以下几点：

1. 索引不是越多越好。索引可以加速查询，但同时也会影响数据的插入、更新和删除速度。过多的索引会增加数据库的存储空间，同时也会使查询变慢。
2. 尽量使用前缀索引。对于字符串类型的列，可以只对列的前几个字符创建索引，这样可以减少索引的存储空间，提高查询效率。
3. 避免在索引列上使用函数或表达式。如果在索引列上使用函数或表达式，MySQL将不会使用索引，这样会导致查询变慢。
4. 选择合适的数据类型。不同的数据类型在索引中所占用的空间不同，选择合适的数据类型可以减少索引的存储空间，提高查询效率。

![image-20230314154504387](C:\Users\宋宇航\AppData\Roaming\Typora\typora-user-images\image-20230314154504387.png)

### 10、怎么优化sql查询慢的问题, 然后还有什么其他解决方案?

1. 创建索引：索引可以大大提高查询速度，尤其是对于大型表和经常查询的列。在创建索引时，需要根据实际查询需求选择适当的索引类型，以及索引的列和顺序。
2. 优化查询语句：优化查询语句可以提高查询效率，包括避免使用SELECT *，避免使用子查询，尽量避免使用OR等复杂条件，以及优化JOIN等操作。
3. 分区表：如果表数据量非常大，可以考虑将表按照一定规则进行分区，以便更快地查询和维护数据。
4. 数据库优化：对于大型数据库，可以考虑调整数据库的参数和配置，以便更好地适应查询需求和负载情况。
5. 使用缓存：可以使用缓存技术（如Redis）来缓存查询结果，以减少对数据库的查询压力，提高查询速度。
6. 水平分库分表：对于数据量非常大的应用，可以考虑使用分库分表的技术，将数据分散到多个数据库或表中，以便更好地处理查询压力。
7. 使用NoSQL数据库：对于一些非结构化数据或对数据一致性要求不高的场景，可以考虑使用NoSQL数据库，以提高查询速度和扩展性。

## 五、计算机网络

### 1、TCP在哪一层？你只需要告诉我在哪一层就行，不要说太多

TCP（传输控制协议）位于网络协议栈的传输层（Transport Layer），负责为应用程序提供可靠的端到端通信服务。TCP通过三次握手建立连接，保证数据传输的可靠性，并通过流量控制和拥塞控制机制来控制数据传输的速率和流量，确保网络的可靠性和高效性。

在OSI模型和TCP/IP模型中，传输层位于网络层和应用层之间，主要负责为应用程序提供端到端的数据传输服务，是网络协议栈中非常重要的一层。除了TCP以外，UDP（用户数据报协议）也是传输层的协议之一，但是它不提供可靠的数据传输服务，适用于对数据传输时延和带宽要求较高的应用场景，如实时语音、视频等。

### 2、那HTTP呢，在哪一层？

HTTP（超文本传输协议）是一种应用层协议，它是建立在TCP协议之上的。HTTP协议规定了客户端和服务器之间的通信格式和通信规则，用于传输超文本数据，如HTML、CSS、JavaScript等。

在OSI模型和TCP/IP模型中，应用层是最高层的网络协议层，负责定义应用程序与网络之间的接口和通信规则，应用层协议包括HTTP、FTP、SMTP等。应用层协议通过下层的协议（如TCP、UDP）来传输数据，最终将数据通过物理层传输到接收方。

因此，HTTP协议位于TCP协议之上，属于应用层协议。

### 3、https和http的区别

HTTP和HTTPS都是用于在网络上传输数据的协议，但是它们之间有几个关键的区别。

1. 安全性：HTTPS是基于HTTP协议的加密版本，通过使用SSL/TLS协议来加密网络传输的数据，从而提高了数据的安全性。HTTPS协议可以防止网络上的恶意攻击者窃取数据、篡改数据或者冒充服务器进行欺骗。
2. 数据传输速度：由于HTTPS需要使用SSL/TLS协议进行加密和解密数据，因此比HTTP协议传输数据的速度要慢一些。
3. 端口：HTTP协议默认使用端口80进行通信，而HTTPS协议默认使用端口443进行通信。
4. 证书：HTTPS协议需要使用SSL/TLS证书来验证服务器的身份和安全性。如果证书被伪造或者过期，用户在访问该网站时可能会收到警告信息。
5. SEO：Google在2014年已经明确表示，HTTPS将作为搜索引擎排名的信号因素，使用HTTPS协议的网站可能会获得更高的排名。

综上所述，HTTPS相比HTTP协议更加安全，但传输速度较慢。如果你的网站需要处理敏感数据或者需要保护用户隐私，建议使用HTTPS协议。

### 4、tcp和udp区别

TCP（Transmission Control Protocol）和UDP（User Datagram Protocol）都是在互联网上传输数据时使用的传输层协议，它们之间有以下区别：

1. 可靠性：TCP是面向连接的协议，提供可靠的数据传输和错误恢复机制。UDP则是面向无连接的协议，不保证数据传输的可靠性和顺序性，但传输速度更快。
2. 速度：由于TCP提供了一些可靠性的机制，因此它的数据传输速度相对较慢。UDP没有提供可靠性机制，所以传输速度更快。
3. 数据大小限制：TCP传输数据的大小受限于MTU（最大传输单元），一般为1500字节。UDP没有这个限制，可以传输更大的数据包。
4. 连接：TCP需要在传输数据前进行连接的建立，这种连接需要一定的时间。UDP没有连接的概念，直接发送数据。
5. 流量控制：TCP可以进行流量控制，防止过多的数据注入引起网络拥塞。UDP没有流量控制的机制，容易引起网络拥塞。



## 5、用过哪些http方法，有什么区别

常用的HTTP方法包括GET、POST、PUT、DELETE、HEAD、OPTIONS等，它们分别有不同的用途和特点。

1. GET：用于获取资源，通常用于获取页面、图片等静态资源，不会修改服务器上的数据，且请求参数会被附加到URL的末尾，因此不适合传输敏感信息。
2. POST：用于向服务器提交数据，通常用于提交表单数据、上传文件等，请求参数会被放在请求体中，因此适合传输大量的数据和敏感信息。
3. PUT：用于更新服务器上的资源，请求参数会被放在请求体中，通常用于更新单个资源或上传新的资源。
4. DELETE：用于删除服务器上的资源，通常用于删除单个资源，请求参数会被放在URL中。
5. HEAD：与GET方法类似，但只返回响应头部信息，不返回响应体，通常用于获取资源的元数据信息。
6. OPTIONS：用于查询服务器支持的HTTP方法和通信选项，通常用于测试服务器功能和调试。

## 六、Git

### 1、说一下merge和rebase的区别？

Merge是将两个分支合并成一个新的分支，保留原有分支的提交历史，将两个分支的代码合并起来。在执行Merge命令时，Git会自动创建一个新的合并提交（merge commit），将两个分支的代码合并起来。这样做的好处是，可以很清晰地看出各个分支的提交历史，方便代码追溯和版本回退。但是，由于需要创建新的合并提交，因此会使得分支历史变得比较复杂，不太利于代码仓库的管理和维护。

Rebase是将一个分支的提交历史应用到另一个分支上，创建一条新的线性提交历史，不会产生新的合并提交。在执行Rebase命令时，Git会将当前分支的提交暂时保存起来，然后将当前分支指向目标分支，再将保存的提交逐个应用到目标分支上。这样做的好处是，可以使得分支历史变得更加简洁和清晰，不会产生多余的合并提交，方便代码仓库的管理和维护。但是，由于会改变原有分支的提交历史，因此可能会对其他开发者造成一定的影响，需要谨慎使用。

因此，Merge适用于需要保留原有分支提交历史的情况，Rebase适用于需要使得分支历史更加清晰简洁的情况。选择哪种方式合并分支，需要根据具体的情况来决定。



## 七、操作系统

### 1、进程, 线程, 协程的区别  *2

- 进程: 进程是具有一定独立功能的程序，进程是系统资源分配和调度的最小单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。
- 线程: 线程是进程的一个实体,线程是内核态,而且是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。
- 协程: 协程是一种用户态的轻量级线程，协程的调度完全是由用户来控制的。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

### 2、锁

锁是一种用于控制对共享资源的访问的机制，它可以确保同时只有一个线程访问某个共享资源，以避免出现数据竞争和其他并发问题。在并发编程中，锁的种类比较多，常见的包括互斥锁、读写锁、条件变量等。

互斥锁（Mutex）是最常用的锁之一，它可以确保同一时刻只有一个线程访问某个共享资源。在使用互斥锁时，当一个线程获取了锁后，其他线程需要等待该线程释放锁后才能访问该共享资源。读写锁（RWMutex）是另一种常用的锁，它可以允许多个线程同时读取共享资源，但在写操作时需要互斥。



## 八、消息队列

### 1、一致性哈希算法和MQ

一致性哈希算法是一种分布式哈希算法，用于将大量的数据分散存储在不同的节点上，同时保证在节点扩容或缩容时最小化数据迁移的代价。一致性哈希算法的主要思想是将数据的哈希值映射到一个环形空间上，每个节点负责环上一定范围内的数据。当节点发生变化时，只需将其负责的数据迁移到新的节点即可，而不需要将所有的数据重新分布。一致性哈希算法在分布式缓存、负载均衡等领域得到了广泛应用。

消息队列（MQ）是一种解耦的消息通信方式，用于在不同的应用程序之间异步地传递消息。消息队列将消息发送者和接收者之间的耦合关系分离开来，提高了系统的可扩展性、可靠性和灵活性。消息队列的主要思想是将消息存储在一个队列中，发送者将消息发送到队列中，接收者从队列中取出消息进行处理。消息队列在分布式系统、异步任务处理、日志收集等场景中得到了广泛应用。

虽然一致性哈希算法和消息队列的应用场景不同，但它们在分布式系统中有一些共同的应用，如分布式缓存和分布式任务处理。在这些应用中，一致性哈希算法用于将数据分散存储在不同的节点上，而消息队列用于在不同的节点之间异步地传递任务和数据。这样可以提高系统的可扩展性、可靠性和性能。

### 2、为什么使用MQ以及如何保证MQ的消费顺序

使用消息队列（MQ）的主要目的是解耦应用程序之间的依赖关系，实现异步通信，提高系统的可扩展性、可靠性和灵活性。消息队列可以将消息发送者和接收者之间的耦合关系分离开来，提高系统的吞吐量和性能，同时可以保证消息的可靠性和数据一致性。

在使用MQ时，有时需要保证消息的消费顺序，即确保消息按照发送的顺序被消费。为了保证消息的消费顺序，可以采用以下方法：

1. 分区顺序消费：将消息分区，每个消费者只消费一个分区中的消息，保证每个分区内的消息按照发送顺序消费。
2. 全局顺序消费：将所有的消息发送到一个队列中，只启动一个消费者进行消费，保证消息按照发送顺序消费。
3. 消息排序：在发送消息时，为每个消息设置一个序号，消费者按照序号进行消费，保证消息按照发送顺序消费。
4. 延迟消费：将消息发送到一个延迟队列中，在一定时间后再将消息发送到正式的队列中进行消费，保证消息的顺序性。





