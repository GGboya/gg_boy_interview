# 数聚智造

100-499人 - 小厂



[TOC]



# 一、go语言基础

## 1、GMP熟悉吗？

[2、Golang的协程调度器原理及GMP设计思想 (yuque.com)](https://www.yuque.com/aceld/golang/srxd6d)

在Go中，**线程是运行goroutine的实体，调度器的功能是把可运行的goroutine分配到工作线程上**。



![img](https://cdn.nlark.com/yuque/0/2022/png/26269664/1650776301442-fb76123c-8d0e-4375-af35-b5728a5b1bc7.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_29%2Ctext_5YiY5Li55YawQWNlbGQ%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)



1. **全局队列**（Global Queue）：存放等待运行的G。
2. **P的本地队列**：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建G'时，G'优先加入到P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列。
3. **P列表**：所有的P都在程序启动时创建，并保存在数组中，最多有`GOMAXPROCS`(可配置)个。
4. **M**：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列**拿**一批G放到P的本地队列，或从其他P的本地队列**偷**一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。



**Goroutine调度器和OS调度器是通过M结合起来的，每个M都代表了1个内核线程，OS调度器负责把内核线程分配到CPU的核上执行**。



有关P和M的个数问题



1、P的数量：



- 由启动时环境变量`$GOMAXPROCS`或者是由`runtime`的方法`GOMAXPROCS()`决定。这意味着在程序执行的任意时刻都只有`$GOMAXPROCS`个goroutine在同时运行。



2、M的数量:



- go语言本身的限制：go程序启动时，会设置M的最大数量，默认10000.但是内核很难支持这么多的线程数，所以这个限制可以忽略。
- runtime/debug中的SetMaxThreads函数，设置M的最大数量
- 一个M阻塞了，会创建新的M。



M与P的数量没有绝对关系，一个M阻塞，P就会去创建或者切换另一个M，所以，即使P的默认数量是1，也有可能会创建很多个M出来。



P和M何时会被创建



1、P何时创建：在确定了P的最大数量n后，运行时系统会根据这个数量创建n个P。



2、M何时创建：没有足够的M来关联P并运行其中的可运行的G。比如所有的M此时都阻塞住了，而P中还有很多就绪任务，就会去寻找空闲的M，而没有空闲的，就会去创建新的M。





## 2、协程什么时候会发生阻塞

协程在执行过程中可能会发生阻塞，具体取决于协程所处的执行环境。以下是几种常见的协程阻塞情况：

1. I/O 阻塞：当协程需要进行网络通信、文件读写等 I/O 操作时，如果该操作不能立即完成，协程就会被阻塞。
2. 计算密集型阻塞：当协程需要进行大量计算时，如果这些计算非常耗时，协程就会被阻塞。
3. 锁竞争阻塞：当多个协程同时访问共享资源（如全局变量或同步对象）时，它们之间可能会发生锁竞争，从而导致部分协程被阻塞。

无论哪种情况，当协程被阻塞时，系统会将其挂起并切换到其他正在运行的协程，以确保程序的高效执行。



## 3、怎么控制协程得数量

在 Golang 中，可以通过使用带有缓冲的通道来限制并发数。以下是一个示例代码：

```go
func main() {
    limit := make(chan int, 5) // 限制并发数为 5
    urls := []string{"http://www.example.com", "http://www.google.com", "http://www.github.com"}

    for _, url := range urls {
        limit <- 1 // 尝试向通道中写入数据。如果通道已满，则会阻塞当前协程。
        go func(url string) {
            fmt.Println("Fetching", url)
            time.Sleep(time.Second * 2) // 模拟请求耗时操作
            <-limit // 从通道中读取数据，释放限制的并发数
        }(url)
    }

    time.Sleep(time.Second * 10) // 等待所有协程执行完毕
}
```

这段代码中，我们创建了一个带有缓冲区大小为 5 的通道 `limit`，用于限制同时执行的协程数目。每个要执行的协程在开始执行之前，先尝试向通道中写入一个值，如果通道已满则会被阻塞。在协程执行完成后，从通道中读取数据以释放其中的一个协程位置。

通过这种方式，我们可以方便地控制程序中的并发协程数量，避免资源浪费和程序崩溃等问题。



## 4、如何结束掉一个协程

在 Golang 中，结束一个协程可以通过使用 `context.Context` 来实现。具体步骤如下：

1. 创建一个 `context.Context` 对象，并设置超时时间或取消函数。
2. 在协程中定期调用 `ctx.Done()` 方法，判断是否需要结束协程。
3. 如果需要结束协程，则在协程中执行清理工作并返回。

以下是一个示例代码：

```go
func worker(ctx context.Context) {
    for { // 循环处理任务
        select {
        case <-ctx.Done():
            fmt.Println("Worker stopped due to", ctx.Err())
            return
        default:
            // 处理任务
        }
    }
}

func main() {
    ctx, cancel := context.WithTimeout(context.Background(), time.Second * 5)
    defer cancel()

    go worker(ctx)

    time.Sleep(time.Second * 10) // 等待一段时间，让 worker 协程运行

    fmt.Println("Main done.")
}
```

在这个例子中，我们创建了一个名为 `worker` 的协程，并传入一个 `context.Context` 对象作为参数。在 `worker` 协程中，我们在一个死循环中不断地处理任务，但同时也会定期检查 `ctx.Done()` 是否被触发。当父协程在 5 秒钟后调用了 `cancel()` 函数时，`ctx.Done()` 就会被触发，此时 `worker` 协程会进行清理并退出。

通过这种方式，我们可以在需要时优雅地结束掉一个协程，避免出现死锁或资源泄漏等问题。



## 5、context了解嘛

在Golang中，Context是一个接口，用于跨API和进程传递请求范围的数据、取消信号和超时值。它可以在一组相关的API调用之间传递上下文信息，以便这些API调用都能够访问同样的一些值。例如，一个HTTP请求处理器可能会创建一个Context对象并将它传递给执行某些任务的函数，这些函数可以使用Context对象来检查是否存在取消信号或超时值，并根据需要采取行动。

Context接口提供了一些方法，例如WithValue()、Deadline()和Done()等等，用于管理上下文信息。它还支持嵌套上下文，这意味着您可以将一个Context对象作为另一个Context对象的父级，从而创建具有层次结构的上下文体系。

在Golang中广泛使用的一些网络框架（如gin和echo）也支持Context对象，它们允许开发人员在请求处理期间访问和修改Context对象中的值。



## 6、channel有缓冲和无缓冲得区别

无缓冲channel在接收操作之前必须有一个正在等待的发送操作，否则接收操作将被阻塞。这意味着发送和接收是同步的，即发送操作会阻塞直到另一个goroutine对该channel进行接收操作。因为无缓冲channel需要发送和接收操作同时发生，所以它通常用于goroutine之间的同步，例如确保所有goroutine都完成了某个任务后再继续执行下一步。

有缓冲channel允许在没有对应接收方的情况下进行一定数量的发送操作。这种类型的channel可以使用make函数带有第二个参数（缓冲区大小）来创建。当channel的缓冲区已满时，发送操作会被阻塞，而当缓冲区为空时，接收操作会被阻塞。有缓冲channel通常用于异步消息传递，例如当发送方生成数据的速度高于接收方处理数据的速度时，可以使用有缓冲channel来避免发送方阻塞。

总的来说，无缓冲channel用于goroutine之间的同步，并且在发送和接收之间提供了强制同步。而有缓冲channel则可用于异步的、非阻塞的消息传递。



## 7、内存泄漏的分析

内存泄漏是指程序在运行时不再需要的内存空间被错误地保留下来，导致系统可用内存逐渐减少。通常情况下，内存泄漏会导致应用程序变得缓慢或崩溃，因此对于任何长时间运行的程序，内存泄漏都是一个非常重要的问题。

以下是一些分析内存泄漏的方法：

1. 使用内存监视工具：可以使用一些内存监视工具，例如Valgrind、Golang的pprof等，这些工具可以帮助你检测出可能存在的内存泄漏问题。
2. 分析代码：通过分析代码并寻找不正确的内存分配和释放操作，可以确定内存泄漏的原因。例如，可能会发现在某些函数中创建了大量的内存对象，但没有释放它们，或者某些指针没有被正确地解除引用。
3. 检查循环引用：当两个对象互相引用时，就可能会发生内存泄漏。例如，在Golang中，如果一个对象持有对另一个对象的引用，而另一个对象也持有对第一个对象的引用，则可能会出现内存泄漏。可以检查是否存在这样的循环引用，并考虑如何打破它们。
4. 调整代码结构：一些内存泄漏问题可能与程序的设计有关。通过调整代码结构，例如减少不必要的对象创建和保存，可以避免这些内存泄漏问题。

总之，分析内存泄漏需要仔细的代码审查和测试，并且需要使用专业的工具来帮助寻找潜在问题。一旦确定了内存泄漏的原因，就可以采取适当的措施来解决问题，例如修复代码或增加垃圾回收等功能。



## 8、结构体json包，不加tag会怎么样

在Golang中，如果一个结构体类型没有任何字段标记（tag），那么在使用encoding/json包或其他JSON序列化/反序列化库时，该类型的实例将不会被正确地编码或解码。

当你尝试将一个未标记的结构体对象编码为JSON字符串时，JSON序列化库将仅序列化结构体中公开的导出字段，而忽略所有不可导出字段。这可能会导致一些重要的数据在编码过程中丢失，并可能会导致解析JSON字符串时出现错误或缺少一些信息。

同样地，如果你尝试从一个JSON字符串中反序列化到一个未标记的结构体对象时，JSON序列化库可能无法正确地恢复所有字段的值。例如，如果JSON字符串中包含了一些附加的属性或属性名称拼写有误，那么这些属性可能会被忽略或无法正确解析。

因此，为了确保正确的JSON序列化和反序列化，强烈建议在定义结构体类型时为每个字段添加JSON tag。这将使JSON序列化库了解如何将结构体字段映射到JSON属性，并确保在编码和解码期间不会出现任何问题。



# 二、计网

## 9、打开一个网页的过程，发生了什么

打开一个网页通常涉及到以下步骤：

1. DNS解析：浏览器首先需要将要访问的URL转换为IP地址，这个过程叫做DNS解析。浏览器向本地DNS服务器发出请求，获取目标URL所对应的IP地址。
2. 建立连接：一旦浏览器获得了目标URL的IP地址，它会尝试与目标服务器建立TCP连接。在此过程中，浏览器向服务器发送一个SYN报文，请求建立连接。
3. 发送HTTP请求：一旦建立了TCP连接，浏览器就可以将HTTP请求发送到服务器。HTTP请求通常包括请求方法（如GET或POST）、请求头、请求正文等信息。
4. 服务器处理请求：当服务器收到请求后，它会根据请求的内容来执行相应的操作。例如，服务器可能会查找请求的资源并返回相应的HTML页面、JSON数据等。
5. 接收响应：如果服务器能够成功处理请求，它将会返回一个HTTP响应，响应通常包括状态码、响应头、响应正文等信息。
6. 渲染页面：一旦浏览器接收到HTTP响应，它将开始渲染页面。浏览器会根据HTML、CSS和JavaScript代码来构建出页面，并且会处理一些交互功能，例如点击链接，提交表单等。
7. 断开连接：一旦浏览器完成了页面的渲染，它将会关闭与服务器的TCP连接。这也意味着，如果用户想再次访问该网页，浏览器需要重新执行所有步骤。



## 10、TCP的状态

CP（传输控制协议）是一种面向连接的、可靠的协议，它提供了流控制、拥塞控制和错误恢复机制等功能。在TCP连接建立期间和连接维护期间，连接状态会不断地发生变化，以下是TCP连接的一些常见状态：

1. CLOSED：表示TCP连接处于关闭状态，即未建立或已经关闭。在这个状态下，TCP无法发送或接收数据。
2. LISTEN：表示服务器正在监听传入的连接请求。当服务器进入LISTEN状态时，它可以接受来自客户端的连接请求。
3. SYN_SENT：表示客户端已经向服务器发送了一个SYN报文，并且正在等待服务器的确认（ACK）。
4. SYN_RECEIVED：表示服务器已经收到了客户端发送的SYN报文，并返回了自己的SYN和ACK报文。在此状态下，服务器等待客户端回应确认（ACK）。
5. ESTABLISHED：表示TCP连接已经成功建立，并且数据可以被安全地传输。在此状态下，TCP可以进行双向通信，即客户端可以向服务器发送数据，服务器也可以向客户端发送数据。
6. FIN_WAIT_1：表示客户端已经发送了FIN报文，请求关闭连接，但仍然等待服务器发送最后一次数据。
7. FIN_WAIT_2：表示客户端已经接收到服务器发送的最后一次数据，并且发送了ACK报文，但仍然在等待服务器发送FIN报文。
8. TIME_WAIT：表示TCP连接已经关闭，但是仍然等待可能会出现的延迟数据。在此状态下，TCP会保持连接状态2MSL（两倍最大段生存时间）以确保所有数据都已经被接收。
9. CLOSE_WAIT：表示服务器已经收到了客户端的FIN报文，即将关闭连接，但仍然在等待客户端发送最后一次数据。
10. LAST_ACK：表示服务器已经发送了最后一次数据，并且请求关闭连接，但仍然在等待客户端发送ACK报文。在接收到ACK报文后，TCP连接进入CLOSED状态。



## 11、直接讲三次握手吧

TCP连接的建立过程使用了三次握手（three-way handshake）协议，以下是三次握手的过程：

1. 第一次握手：客户端向服务器发送一个SYN（同步）报文，请求建立连接。该报文包含一个随机生成的初始序列号（ISN）。
2. 第二次握手：服务器收到客户端发送的SYN报文后，会回复一个SYN和ACK（确认）报文，表示同意建立连接，并且确认客户端的SYN报文已经收到。服务器也会生成一个随机的ISN作为响应的初始序列号。
3. 第三次握手：客户端接收到服务器返回的SYN/ACK报文后，会发送一个ACK报文给服务器，这个报文中包含服务器发送的序列号加1作为对服务器的响应。服务器收到客户端的ACK报文后，就可以认为TCP连接已经建立，可以开始进行数据传输了。

在三次握手的过程中，每个握手都需要获得另一方的确认才能继续进行，这样可以确保连接的可靠性和安全性。如果其中任何一个握手未能成功完成，连接就不会被建立。同时，由于TCP协议具有可靠的错误恢复机制，因此即使某个握手出现问题，连接仍然可以被重试和重新建立。



## 12、为什么两次握手不行？

TCP使用三次握手来建立连接，其中至少需要三个交换（SYN，SYN-ACK和ACK）才能确保连接的可靠性。两次握手可能会导致以下问题：

1. 可能存在旧连接：在使用两次握手时，如果客户端发送了一个SYN报文但没有收到服务器的响应，那么客户端将重新发送一个SYN报文。但是，第一次发送的报文可能已经到达了服务器并在某些情况下被处理了，这样就会创建一个旧连接。当客户端重新发送SYN报文时，服务器将会认为这是一个新连接，并且可能会继续处理旧连接中的数据，从而导致数据混乱。
2. 面临攻击风险：因为TCP是面向连接的协议，攻击者可以在两次握手期间注入恶意数据，从而导致两端的数据不同步。例如，如果攻击者在两次握手期间注入数据包，它会被视为正常的数据，从而导致连接的错误状态。
3. 无法正确确认对方的序列号：在TCP连接建立过程中，每个端点都需要将自己的初始序列号（ISN）发送给对方。这个序列号用于确保数据传输的完整性和可靠性。在两次握手过程中，每个端点只发送了一个SYN报文和一个ACK报文，因此无法确保对方的序列号是否正确。



## 13、tcp是双向的还是单向的

TCP（传输控制协议）是一种双向的协议。它允许在两个应用程序之间进行双向通信，即客户端可以向服务器发送数据，服务器也可以向客户端发送数据。

TCP连接的建立过程使用了三次握手协议，这样可以确保两个端点都能够相互通信，并且能够建立双向通信的连接。一旦TCP连接建立成功，任何一方都可以在连接上发送数据，并且对方将能够接收、处理和响应这些数据。

在TCP连接中，每条数据都被切成多个数据段（segment）并发送到对端。每个数据段中都包含一个序列号和确认号，以确保数据的可靠传输和正确接收。当接收到数据段时，接收端会发送一个确认报文（ACK）给发送端，以表示已经成功接收并处理了数据。

总的来说，TCP是一种双向通信的协议，它允许两个应用程序之间在连接上进行双向通信，并且提供了可靠的数据传输和错误恢复机制，以确保数据的完整性和可靠性。



## 14、tcp和udp的区别

**TCP 和 UDP 区别：**

*1. 连接*

- TCP 是面向连接的传输层协议，传输数据前先要建立连接。
- UDP 是不需要连接，即刻传输数据。

*2. 服务对象*

- TCP 是一对一的两点服务，即一条连接只有两个端点。
- UDP 支持一对一、一对多、多对多的交互通信

*3. 可靠性*

- TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。
- UDP 是尽最大努力交付，不保证可靠交付数据。但是我们可以基于 UDP 传输协议实现一个可靠的传输协议，比如 QUIC 协议，具体可以参见这篇文章：[如何基于 UDP 协议实现可靠传输？(opens new window)](https://xiaolincoding.com/network/3_tcp/quic.html)

*4. 拥塞控制、流量控制*

- TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。
- UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。

*5. 首部开销*

- TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 `20` 个字节，如果使用了「选项」字段则会变长的。
- UDP 首部只有 8 个字节，并且是固定不变的，开销较小。

*6. 传输方式*

- TCP 是流式传输，没有边界，但保证顺序和可靠。
- UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。

*7. 分片不同*

- TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。
- UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。



## 15、http请求你知道吗，get,post

HTTP（HyperText Transfer Protocol）是一种客户端-服务器之间的协议，用于在Web上传输数据。在HTTP中，GET和POST是最常见的两种请求方法。

GET请求： GET请求用于从服务器获取资源，通过URL向服务器传递请求参数，并返回响应内容。例如，在浏览器地址栏输入URL时就会发起一个GET请求。GET请求将请求参数拼接在URL后面，可以被缓存，以及容易被浏览器记录和收藏等。但是，由于GET请求将请求参数暴露在URL中，因此不适合发送敏感信息。

POST请求： POST请求用于向服务器提交资源或数据，且请求的数据通常比较大且包含在请求体中。与GET请求不同，POST请求将请求参数放在请求体中，这意味着POST请求不能被浏览器缓存，也不容易被浏览器记录和收藏。POST请求也更适合发送敏感信息，因为请求参数不会被暴露在URL中。

除了以上两种请求方法外，还有其他一些请求方法，例如PUT、DELETE、HEAD、OPTIONS等，每个方法都有其特定的用途和语义。但是，GET和POST是最常用的两种请求方法，用于处理大部分Web应用程序场景。



## 16、get和post传输数据有什么区别？

GET和POST是HTTP协议中两种常用的请求方法，它们在数据传输上有以下几点区别：

1. 参数位置：GET请求将请求参数附加在URL后面，而POST请求则将请求参数放置在请求体中。
2. 安全性：由于GET请求将请求参数暴露在URL中，所以不适合传输敏感信息，例如密码或银行账户等。而POST请求的请求参数嵌入在请求体中，相对安全一些，因为请求参数不会被直接暴露在URL中。但是此种方式仍然需要保证数据传输过程的安全性。
3. 传输数据大小限制：GET请求将请求参数作为URL的一部分，URL的长度有限制，通常为2048个字符。而POST请求没有这样的限制，可以传输较大的数据量。
4. 缓存：GET请求可以被浏览器缓存，而POST请求则不能被缓存。
5. 幂等性：GET请求具有幂等性，即多次请求返回的结果应该是一致的。而POST请求不具有幂等性，一个POST请求可能会导致服务器状态的改变，多次请求返回的结果不一定一致。

## 17、http有没有状态

HTTP协议是一种无状态的协议，也就是说，HTTP服务器不会在客户端请求之间保留任何状态信息。每个HTTP请求都是独立的，并且包含了所有必要的信息以便服务器进行处理和响应。

这种无状态的特点使得HTTP协议可以更加简单、灵活和可扩展，因为它不需要维护复杂的会话状态和上下文信息。同时，它也方便了分布式应用程序的开发和部署，因为不同的请求可以被转发到不同的服务器上处理。

然而，在实际的Web应用程序中，通常需要保存一些状态信息，例如用户登录状态、购物车内容等。为了实现这些功能，Web应用程序通常使用一些技术手段来维护状态信息，比如：

1. Cookie：Cookie是一种在客户端存储数据的机制，可以用于在浏览器和Web服务器之间传递状态信息。Web服务器可以将一些标识符或其他信息写入Cookie中，然后在后续的HTTP请求中读取Cookie来获取相应的状态信息。
2. Session：Session是一种在服务器端维护状态信息的机制，它使用Cookie或URL参数来标识当前会话，并在服务器上存储相关的状态信息。当客户端发送新的HTTP请求时，服务器可以根据会话ID来恢复相应的状态信息。

总之，HTTP协议本身是无状态的，但是为了实现一些有状态的功能，Web应用程序通常需要使用一些额外的技术手段来维护状态信息。



## 18、cookie,session这些知道吗

是的，我知道Cookie和Session是Web应用程序常用的状态管理机制。

1. Cookie：Cookie是一种在客户端存储数据的机制，它可以用于在浏览器和Web服务器之间传递状态信息。Cookie通常包含一个名称、一个值和一些可选属性，如过期时间、域名、路径等。Web服务器可以将一些标识符或其他信息写入Cookie中，然后在后续的HTTP请求中读取Cookie来获取相应的状态信息。由于Cookie存储在客户端本地，因此它可以在不同的页面之间共享状态，并且可以保留一定的持久性。
2. Session：Session是一种在服务器端维护状态信息的机制，它使用Cookie或URL参数来标识当前会话，并在服务器上存储相关的状态信息。当客户端发送新的HTTP请求时，服务器可以根据会话ID来恢复相应的状态信息。与Cookie不同，Session存储在服务器端，因此它可以保存更多的状态信息，并且相对更加安全。同时，Session的生命周期也可以控制得更加精确，例如可以设定超时时间，自动清除过期的会话。

需要注意的是，Cookie和Session都有一定的安全风险。例如，如果未正确设置Cookie的属性，可能会导致敏感信息被泄露；而Session劫持攻击可能会导致会话被恶意盗用。因此，在使用Cookie和Session时，需要采取相应的安全措施，例如设置合适的属性、加密敏感信息等。



## 19、和token的区别呢，cookie和session存放在哪里的

Cookie和Session是用于管理Web应用程序状态的机制，而Token则是一种身份验证和授权的机制。它们的不同点在于：

1. 功能：Cookie和Session主要用于管理Web应用程序中的状态信息，例如用户登录状态、购物车内容等；而Token通常用于进行身份验证和授权，以便访问受保护的资源。
2. 存储位置：Cookie存储在浏览器端，Session存储在服务器端；而Token通常是通过HTTP请求头或URL参数传递的，可以存储在任何地方。
3. 安全性：Cookie和Session可能存在一些安全问题，如跨站脚本攻击（XSS）、会话劫持等；而Token可以使用加密算法和数字签名技术来保证安全性。
4. 可扩展性：Cookie和Session通常只适用于单个Web应用程序，无法进行共享或跨域使用；而Token采用了标准化的格式和协议，可以跨多个Web应用程序或服务进行共享和使用。

至于Cookie和Session的存放位置，Cookie保存在浏览器的Cookie文件中，每次请求时会自动发送到服务器；而Session数据通常存储在服务器内存或数据库中，由服务器来维护和管理。

需要注意的是，使用哪种状态管理机制取决于具体的需求和场景。对于需要进行身份验证和授权的场景，Token是一个更加合适的选择；而对于一些简单的状态管理需求，Cookie和Session可能更加易用。





# 三、mysql

## 20、mysql的存储引擎知道吗，讲讲区别

所谓的存储引擎，说白了就是如何存储数据、如何为存储的数据建立索引和如何更新、查询数据等技术的实现方法。MySQL 存储引擎有 MyISAM 、InnoDB、Memory，其中 InnoDB 是在 MySQL 5.5 之后成为默认的存储引擎。

下图是 MySQL 的结构图，索引和数据就是位于存储引擎中：

![img](https://cdn.xiaolincoding.com//mysql/other/1623727651911_20170928110355446.png)

InnoDB

- 是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。
- 实现了四个标准的隔离级别，默认级别是可重复读(REPEATABLE READ)。在可重复读隔离级别下，通过多版本并发控制(MVCC)+ 间隙锁(Next-Key Locking)防止幻影读。
- 主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。
- 内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。
- 支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。

MyISAM

- 设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。
- 提供了大量的特性，包括压缩表、空间数据索引等。
- 不支持事务。
- 不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入(CONCURRENT INSERT)。

总结

- 事务: InnoDB 是事务型的，可以使用 `Commit` 和 `Rollback` 语句。
- 并发: MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。
- 外键: InnoDB 支持外键。
- 备份: InnoDB 支持在线热备份。
- 崩溃恢复: MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。
- 其它特性: MyISAM 支持压缩表和空间数据索引。



## 21、哪些支持事务？

在MySQL中，以下存储引擎支持事务：

1. InnoDB：InnoDB是MySQL中最常用的事务性存储引擎，它支持ACID（原子性、一致性、隔离性和持久性）事务。

而MyISAM和Memory等存储引擎不支持事务。因此，在使用MySQL时，如果需要事务处理功能，则应该选择支持事务的存储引擎，如InnoDB、Falcon等。



## 22、索引是什么，如何创建一个索引，举个例子

在关系型数据库中，索引是一种数据结构，用于加快对表中数据的访问速度。它类似于书籍的目录，可以帮助我们很快地找到需要的数据。

在MySQL中，常见的索引类型包括：

1. B+树索引：B树索引是一种平衡树，它可以高效地支持范围查询和排序操作。在MySQL中，InnoDB存储引擎使用B+树索引来优化查询性能。
2. 哈希索引：哈希索引基于哈希表实现，可以提供非常快的精确匹配查找。但是，它不支持范围查询和排序操作，并且不适合模糊查询。
3. 全文索引：全文索引是一种特殊类型的索引，用于在文本数据中进行全文搜索。在MySQL中，可以使用InnoDB或MyISAM存储引擎创建全文索引。

创建索引可以使用CREATE INDEX语句，例如：

```
CREATE INDEX idx_name ON table_name (column_name);
```

其中idx_name是索引名称，table_name是要创建索引的表名，column_name是要创建索引的列名。

要注意的是，创建过多的索引可能会降低INSERT、UPDATE和DELETE操作的性能，并占用额外的存储空间。因此，在为表创建索引时，应该考虑哪些列需要索引，以及何时需要创建索引。



## 23、联合索引呢？

联合索引是指在多个表列上创建的索引，也称为复合索引。它可以让数据库在多个列上进行快速查询，并且可以优化多列的排序操作。

例如，有一个用户表包含id、name和age三个字段，如果经常需要按照name和age两个字段的顺序进行查询或排序，就可以创建一个联合索引：

```
CREATE INDEX idx_name_age ON user(name, age);
```

这样，当对name和age两个字段进行WHERE子句或ORDER BY子句的操作时，数据库就可以使用此联合索引来提高查询和排序效率。

要注意的是，在使用联合索引时，应该考虑哪些列应该排在前面，这会影响到索引的使用效率。一般来说，应该将最具有选择性的列排在联合索引的最前面，以便最大程度地利用索引的优势。



## 25、sql语句的执行顺序

SQL语句的执行顺序如下：

1. FROM子句：确定要查询的表以及它们之间的关系。
2. WHERE子句：筛选符合条件的记录。
3. GROUP BY子句：将结果集按照指定的列进行分组。
4. HAVING子句：筛选分组后的结果。
5. SELECT子句：选择需要查询的列或计算的表达式。
6. DISTINCT关键字：去除重复行。
7. ORDER BY子句：按照指定的列对结果进行排序。
8. LIMIT关键字：限制返回的结果数量。

需要注意的是，这只是一个大致的执行顺序，实际上，在执行SQL语句时，数据库会根据具体情况对执行顺序进行优化。例如，如果在WHERE子句中使用索引，则查询速度可能会更快，因此数据库可能会优先执行WHERE子句。而且，某些数据库系统可能会有自己的执行顺序规则。因此，在编写SQL语句时，应该尽可能地让其简单明了，并确保可以被正确优化



# 三、分布式

## 26、为什么会选择etcd来注册中心

etcd是一个高可用的分布式键值存储，它提供了一个简单、安全和可靠的方法来存储和管理应用程序和服务的配置数据、元数据和路由信息。etcd主要被用作容器平台（如Kubernetes）和微服务架构中的分布式系统的注册中心。

我认为选择etcd作为注册中心有以下几个原因：

1. 高可用性：etcd是基于Raft算法实现的强一致性分布式系统，具有自动故障转移和恢复机制，因此可以在节点发生故障时保持可用性，避免服务中断。
2. 可靠性：etcd保证所有数据的完整性和一致性，并支持事务操作，防止出现并发冲突。这使得服务注册中心可以依赖etcd提供可靠的数据存储和访问能力。
3. 易于使用：etcd提供了简单易用的API和命令行工具，可以轻松地进行数据的读写和监视。同时，etcd还支持多种编程语言的客户端库，开发人员可以方便地将etcd集成到他们的应用程序中。
4. 性能：etcd的性能非常好，可以处理大量的读写请求，并且可以进行水平扩展，以支持更高的请求吞吐量。
5. 社区支持：etcd是一个开源项目，拥有庞大的用户和开发人员社区。这使得etcd可以获得及时的更新、修复和支持，并且可以与其他开源项目无缝集成。

综上所述，etcd具有高可靠性、易用性、性能优越以及拥有强大的社区支持等特点，因此它是一个非常适合作为注册中心的存储系统。



# 四、项目

## 27、为什么选用gin

Gin是一个基于Go语言的Web框架，它提供了快速轻巧、易用、高效的方式来编写API和Web应用程序。下面是选择Gin作为Web框架的一些原因：

1. 高性能：Gin采用了类似于httprouter的路由算法，可以在处理HTTP请求时快速匹配路由。同时，Gin使用了内存池技术来减少内存分配和垃圾回收的成本，从而提高了Web应用程序的性能。
2. 易用性：Gin提供了简单易用的API，可以轻松地创建HTTP路由、中间件、JSON解析等功能。Gin还支持多种HTTP方法和参数绑定方式，使得开发人员可以更加方便地实现自己的需求。
3. 轻量级：Gin是一个轻量级的Web框架，代码库非常小，并且没有其他复杂的依赖关系。这使得Gin非常适合用于构建微服务或分布式系统中的API。
4. 社区支持：Gin拥有庞大的用户和开发人员社区，可以获得及时的更新、修复和支持。同时，Gin的文档和示例也非常详细和完整，可以帮助开发人员快速入门和学习。
5. 可扩展性：Gin支持中间件，开发人员可以自定义中间件来实现各种功能。此外，Gin还支持集成其他Go语言的库和框架。



## 28、jwt知道是啥吗

JWT全称为JSON Web Token，是一种基于JSON（JavaScript Object Notation）格式的轻量级身份验证机制。它可以使用加密算法对数据进行签名和校验，从而实现身份验证和信息交换。

一个JWT由三个部分组成：头部（Header）、载荷（Payload）和签名（Signature）。其中，头部用于描述信息的元数据，载荷用于存储实际的信息内容，签名用于保证信息的完整性和真实性。

JWT的优点包括：

1. 无状态：由于JWT已经包含了所有必要的信息，服务器不再需要在会话中保存客户端的状态，因此JWT是无状态的，可以更方便地进行扩展和分布式部署。
2. 跨域支持：由于JWT使用标准的Base64编码，可以很方便地通过HTTP请求传递，并且可以跨域使用。
3. 安全性：JWT使用数字签名或加密算法保证了信息的完整性和真实性，并且只有持有密钥的一方才能够对JWT进行修改或解码。
4. 可扩展性：JWT的载荷可以包含任意结构化数据，可以满足各种需求的扩展。
5. 通用性：JWT已经被广泛应用于Web应用程序和服务之间的身份验证和授权，是一种通用的解决方案。

需要注意的是，JWT并不适合用于存储敏感数据，因为它只提供了基本的加密和签名机制。如果需要更高级的安全控制，应该考虑使用其他专门的身份验证和授权机制。



## 29、除了jwt还知道其他的吗

除了JWT，还有其他的身份验证和授权方案，其中比较常见的包括以下几种：

1. OAuth：OAuth是一种开放标准的授权协议，用于允许第三方应用程序在用户授权的情况下访问他们的数据。OAuth支持多种授权流程，例如授权码模式、隐式授权模式等。
2. Basic认证：Basic认证是一种基本的HTTP身份验证机制，它使用Base64编码对用户名和密码进行传输，并且不提供加密和签名功能。因此，Basic认证只适合用于安全性不高的场景。
3. Digest认证：Digest认证是一种改进的HTTP身份验证机制，它使用摘要算法对用户名和密码进行加密，从而提高了安全性。但是，Digest认证仍然存在一些漏洞，容易受到中间人攻击等威胁。
4. SAML：SAML（Security Assertion Markup Language）是一种基于XML的标准，用于在不同的网络安全域之间传输身份验证和授权数据。SAML定义了一套完整的身份验证和授权流程，包括单点登录、断言和元数据等概念。
5. OpenID Connect：OpenID Connect是一个基于OAuth 2.0协议的身份验证和授权协议，它提供了一种连接多种身份验证和授权协议的标准化方式。OpenID Connect支持单点登录、身份信息交换等功能。

需要根据具体需求选择合适的身份验证和授权方案，一般来说，JWT是一种轻量级、通用性强的解决方案，适用于大多数场景。而OAuth适用于需要访问第三方API或数据的场景，SAML适用于企业内部集成系统的场景，OpenID Connect适用于互联网应用程序的场景。



# 五、场景题

30：微信朋友圈，两个好友才能可见。你怎么设计？

假设有三个表：users、friends和posts，其中users表存储用户信息，friends表存储好友关系，posts表存储朋友圈动态。可以通过以下SQL查询语句来实现两个好友才能可见的微信朋友圈：

```sql
SELECT p.content
FROM posts AS p
INNER JOIN friends AS f1 ON p.user_id = f1.user_id
INNER JOIN friends AS f2 ON p.user_id = f2.user_id
WHERE f1.friend_id = [好友1的ID] AND f2.friend_id = [好友2的ID]
```

该查询语句使用了INNER JOIN连接posts和friends表，将朋友圈动态与好友关系进行关联。其中，f1.friend_id和f2.friend_id分别表示好友1和好友2的用户ID，p.user_id表示发朋友圈的用户ID。当且仅当好友1和好友2都在发朋友圈的用户的好友列表中时，该朋友圈动态才会被查询出来。

