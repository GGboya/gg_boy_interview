# 温柔群第一次模拟面试内容汇总

## 1、计算机网络

#### 1、 [浏览器访问百度的整个过程](#1)

#### 2、[UDP和TCP的区别](#2)

#### 3、[TCP三次握手的过程](#3)

#### 4、[Time Wait出现在哪个阶段？](#4)

#### 5、[为什么要四次挥手](#5)

## 2、操作系统

#### 6、[线程数据如何同步，除了锁之外还有什么手段](#6)

#### 7、[死锁和如何避免死锁](#7)

#### 8、[进程间的通信方式](#8)

#### 9、[什么是孤儿进程、僵尸进程](#9)

## 3、数据库

#### 10、[数据库事务ACID，以及各自的实现原理，MVCC](#10)

#### 11、[Redis分布式锁怎么实现的？](#11)

## 4、数据结构

#### 12、[谈谈你对红黑树的理解？](#12)

#### 13、[哪些场景应用到了红黑树？](#13)





1、浏览器访问百度的整个过程   <a name ="1"></a>

浏览器向DNS服务器发出解析域名的请求；
DNS服务器将"www.baidu.com"域名解析为对应的IP地址，并返回给浏览器；
浏览器与百度服务器进行三次握手，建立TCP连接；
浏览器发出HTTP请求报文；
服务器回复HTTP响应报文；
浏览器解析响应报文，渲染HTML内容，并显示在页面上；
收发报文结束，释放TCP连接，执行四次挥手。
更为详细的解释，[2.2 键入网址到网页显示，期间发生了什么？ | 小林coding (xiaolincoding.com)](https://xiaolincoding.com/network/1_base/what_happen_url.html#孤单小弟-http)



2、UDP和TCP的区别<a name ="2"></a>

1. 连接性：UDP是面向无连接的协议，即发送数据前不需要建立连接，也不需要维护连接状态，因此传输效率比TCP高。而TCP是面向连接的协议，需要先建立连接，传输数据结束后还需要释放连接，因此传输效率比UDP低。
2. 可靠性：UDP不保证数据传输的可靠性，发送数据后不会对其进行检查，如果数据丢失或出现错误，UDP不会重传数据。而TCP通过各种机制确保数据传输的可靠性，如确认机制、重传机制、流量控制和拥塞控制等，可以保证数据的完整性和可靠性。
3. 速度：UDP的速度比TCP快，因为UDP在发送数据时不需要等待确认或重传丢失的数据，可以直接发送下一批数据。而TCP需要等待确认和重传丢失的数据，会导致传输延迟增加。
4. 传输特性：UDP支持广播和多播等特性，可以一次性向多个客户端发送相同的数据，而TCP不支持这些特性。



3、TCP三次握手的过程<a name ="3"></a>

TCP 是面向连接的协议，所以使用 TCP 前必须先建立连接，而**建立连接是通过三次握手来进行的**。三次握手的过程如下图：

![TCP 三次握手](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png)

- 一开始，客户端和服务端都处于 `CLOSE` 状态。先是服务端主动监听某个端口，处于 `LISTEN` 状态

![第一个报文 —— SYN 报文](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230500953.png)

- 客户端会随机初始化序号（`client_isn`），将此序号置于 TCP 首部的「序号」字段中，同时把 `SYN` 标志位置为 `1`，表示 `SYN` 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 `SYN-SENT` 状态。

![第二个报文 —— SYN + ACK 报文](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230504118.png)

- 服务端收到客户端的 `SYN` 报文后，首先服务端也随机初始化自己的序号（`server_isn`），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 `client_isn + 1`, 接着把 `SYN` 和 `ACK` 标志位置为 `1`。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 `SYN-RCVD` 状态。

![第三个报文 —— ACK 报文](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230508297.png)

- 客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 `ACK` 标志位置为 `1` ，其次「确认应答号」字段填入 `server_isn + 1` ，最后把报文发送给服务端，这次报文可以携带客户到服务端的数据，之后客户端处于 `ESTABLISHED` 状态。
- 服务端收到客户端的应答报文后，也进入 `ESTABLISHED` 状态。

从上面的过程可以发现**第三次握手是可以携带数据的，前两次握手是不可以携带数据的**，这也是面试常问的题。

一旦完成三次握手，双方都处于 `ESTABLISHED` 状态，此时连接就已建立完成，客户端和服务端就可以相互发送数据了。







4、Time Wait出现在哪个阶段？<a name ="4"></a>

天下没有不散的宴席，对于 TCP 连接也是这样， TCP 断开连接是通过**四次挥手**方式。

双方都可以主动断开连接，断开连接后主机中的「资源」将被释放，四次挥手的过程如下图：

![客户端主动关闭连接 —— TCP 四次挥手](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230614791.png)

- 客户端打算关闭连接，此时会发送一个 TCP 首部 `FIN` 标志位被置为 `1` 的报文，也即 `FIN` 报文，之后客户端进入 `FIN_WAIT_1` 状态。
- 服务端收到该报文后，就向客户端发送 `ACK` 应答报文，接着服务端进入 `CLOSE_WAIT` 状态。
- 客户端收到服务端的 `ACK` 应答报文后，之后进入 `FIN_WAIT_2` 状态。
- 等待服务端处理完数据后，也向客户端发送 `FIN` 报文，之后服务端进入 `LAST_ACK` 状态。
- 客户端收到服务端的 `FIN` 报文后，回一个 `ACK` 应答报文，之后进入 `TIME_WAIT` 状态
- 服务端收到了 `ACK` 应答报文后，就进入了 `CLOSE` 状态，至此服务端已经完成连接的关闭。
- 客户端在经过 `2MSL` 一段时间后，自动进入 `CLOSE` 状态，至此客户端也完成连接的关闭。

你可以看到，每个方向都需要**一个 FIN 和一个 ACK**，因此通常被称为**四次挥手**。

第三次挥手之后，才会处于Time Wait状态。





5、为什么要四次挥手<a name ="5"></a>

在计算机网络中，TCP协议使用三次握手建立连接，四次挥手关闭连接。挥手需要四次的原因是，TCP协议的设计是为了确保可靠的数据传输，其中包括保证双方完整地关闭连接。

具体来说，四次挥手的过程如下：

1. 主机A向主机B发送一个FIN分节，请求关闭连接。
2. 主机B回复一个ACK分节，表示已收到关闭请求。
3. 主机B向主机A发送一个FIN分节，请求关闭连接。
4. 主机A回复一个ACK分节，表示已收到关闭请求。

需要四次挥手的原因在于，当主机A向主机B发送FIN分节请求关闭连接时，主机B可能还有一些数据尚未传输完毕。主机B需要先发送一个ACK分节，表示已收到关闭请求，但是还需要继续传输未完成的数据。主机A收到ACK分节后，就知道还需要等待一段时间，以确保主机B传输完未完成的数据，然后才能发送最后一个ACK分节，表示连接已经关闭。这就是为什么需要四次挥手，以保证双方都完整地关闭连接，避免数据丢失或者不完整的情况发生。





6、线程数据如何同步，除了锁之外还有什么手段<a name ="6"></a>

1. 信号量：信号量是一种计数器，可以用来控制同时访问共享资源的线程数。当线程需要访问共享资源时，它会尝试获取信号量的锁。如果当前信号量的值为0，表示已经有其他线程在访问该资源，那么当前线程就会被阻塞，直到其他线程释放了该资源的信号量。当线程访问完共享资源后，它会释放信号量的锁，使其他线程可以访问该资源。
2. 互斥量：互斥量是一种特殊的锁，它可以用来保护共享资源的访问。互斥量和普通的锁类似，但是它有一个特殊的属性，即只能被一个线程持有。当一个线程尝试获取互斥量的锁时，如果互斥量已经被其他线程持有，那么该线程会被阻塞，直到其他线程释放了该互斥量的锁。互斥量通常用于保护对共享资源的访问。
3. 读写锁：读写锁是一种特殊的锁，它可以同时支持多个线程对共享资源的读操作，但只能支持一个线程对共享资源的写操作。当一个线程需要对共享资源进行读操作时，它会尝试获取读锁。如果当前有其他线程持有写锁，那么当前线程就会被阻塞，直到写锁被释放。当一个线程需要对共享资源进行写操作时，它会尝试获取写锁。如果当前有其他线程持有读锁或写锁，那么当前线程就会被阻塞，直到所有锁都被释放。
4. 条件变量：条件变量是一种用于线程间通信的机制，它可以使一个线程等待另一个线程发出信号。当一个线程需要等待某个条件满足时，它会调用条件变量的等待函数，该函数会将当前线程阻塞，并释放锁。当另一个线程满足条件后，它会调用条件变量的通知函数，通知等待的线程继续执行。条件变量通常用于线程间同步，以避免线程的无效循环等待。



7、死锁和如何避免死锁<a name ="7"></a>

当两个线程为了保护两个不同的共享资源而使用了两个互斥锁，那么这两个互斥锁应用不当的时候，可能会造成**两个线程都在等待对方释放锁**，在没有外力的作用下，这些线程会一直相互等待，就没办法继续运行，这种情况就是发生了**死锁**。

死锁只有**同时满足**以下四个条件才会发生：

- 互斥条件；
- 持有并等待条件；
- 不可剥夺条件；
- 环路等待条件；

如何避免死锁：

（1）那么避免死锁问题就只需要破环其中一个条件就可以，最常见的并且可行的就是**使用资源有序分配法，来破环环路等待条件**。

（2）银行家算法



8、进程间的通信方式<a name ="8"></a>

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/3-%E6%8F%90%E7%BA%B2.jpg)

1. 管道（Pipe）：管道是一种半双工的通信方式，它只能用于具有亲缘关系（父子进程或兄弟进程）的进程之间的通信。管道分为匿名管道和命名管道两种。
2. 共享内存（Shared Memory）：共享内存是将同一段内存空间映射到多个进程的地址空间中，从而使这些进程可以直接访问同一块物理内存。共享内存是一种高效的通信方式，但是需要注意进程间的同步和互斥问题。
3. 消息队列（Message Queue）：消息队列是一种进程间通信方式，允许在不同进程之间传递消息。消息队列是异步的，因此发送消息的进程不需要等待接收消息的进程响应。消息队列可以实现消息的存储和转发，但需要确保消息的正确性和可靠性。
4. 信号量（Semaphore）：信号量是一种计数器，用于控制对共享资源的访问。进程可以使用信号量来协调对共享资源的访问，以避免竞争和死锁问题。
5. 套接字（Socket）：套接字是一种网络通信方式，可以在不同的计算机之间进行进程间通信。套接字提供了一种通用的、可靠的、高效的通信方式，但需要使用网络协议进行通信，因此比较复杂。
6. 信号是一种异步通知机制，用于向进程发送通知和中断请求。当一个进程接收到一个信号时，它会执行与该信号相关联的处理程序（信号处理函数）来响应信号。进程可以向自身或其他进程发送信号，从而实现进程间通信。常见的信号有SIGTERM、SIGINT、SIGKILL、SIGUSR1等。信号的处理可以通过signal函数或sigaction函数进行设置。信号通常用于进程间的异步事件通知和进程的中断处理。



9、什么是孤儿进程、僵尸进程<a name ="9"></a>

孤儿进程（Orphan Process）是指其父进程已经退出或异常终止，而它本身还在系统中运行的进程。孤儿进程将由init进程（进程号为1）接管，init进程会定期扫描进程列表，对于孤儿进程则会调用wait函数等待其结束，并回收其占用的系统资源。

僵尸进程（Zombie Process）是指一个已经完成执行（退出）的进程，但其在进程表中的进程描述符仍然存在，因为其父进程没有正常地调用wait或waitpid函数来回收它的资源，这些进程成为僵尸进程。僵尸进程会占用系统资源，因此需要及时清除。



10、数据库事务ACID，以及各自的实现原理，MVCC<a name ="10"></a>

数据库事务ACID是指原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）这四个特性。

- 原子性： 语句要么都执行，要么都不是执行，是事务最核心的特性，事务本身来说就是以原子性历来定义的，实现主要是基于undo log
- 持久性： 保证事务提交之后，不会因为宕机等其他的原因而导致数据的丢失，主要是基于 redo log实现
- 隔离性： 保证事务与事务之间的执行是相互隔离的，事务的执行不会受到其他事务的影响。InnoDB存储引擎默认的数据库隔离级别是 RR ，RR又主要是基于锁机制，数据的隐藏列，undo log类 以及 next-key lock机制
- 一致性： 事务追求的最终目标，一致性的实现即需要数据库层面的保障，也需要应用层面的保障。

[详细请见][MySQL事务之ACID实现原理（全方位解读） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/270209292)





11、Redis分布式锁怎么实现的？<a name ="11"></a>

Redis分布式锁的实现需要使用Redis的原子操作和Lua脚本语言。

以下是一个基本的Redis分布式锁实现的示例代码：

```lua
luaCopy code-- 获取锁
local is_locked = redis.call('setnx', KEYS[1], ARGV[1])
if is_locked == 1 then
    redis.call('expire', KEYS[1], ARGV[2])
    return 1
else
    return 0
end

-- 释放锁
if redis.call('get', KEYS[1]) == ARGV[1] then
    return redis.call('del', KEYS[1])
else
    return 0
end
```

上面的代码中，`setnx`命令用于设置一个键值对，只有当这个键不存在时才会成功。因此，如果获取锁的命令返回1，说明成功获取到锁；否则返回0，说明锁已被其他进程占用。

在获取锁时，还需要使用`expire`命令设置锁的过期时间。这样即使锁没有被释放，也会在一定时间后自动失效，避免死锁的问题。

在释放锁时，需要先判断当前锁是否为自己持有，如果是则可以使用`del`命令删除该键值对，释放锁。

以上是一个基本的Redis分布式锁实现的示例代码，实际应用中还需要考虑更多的场景和细节，如锁超时、宕机等问题。



12、谈谈你对红黑树的理解？<a name ="12"></a>

红黑树是一种自平衡二叉查找树，它能保证在最坏情况下，基本的动态查找、插入、删除操作的时间复杂度为O(log n)，并且具有较为稳定的性能。在C++ STL和Java的TreeMap、TreeSet等标准库中都有广泛应用。

红黑树的节点有两种颜色：红色和黑色。根节点和叶子节点都是黑色的。红色节点必须有一个黑色的父节点。任意节点到其所有后代叶子节点的路径上包含相同数量的黑色节点，这个属性称为黑高度。

通过对红黑树进行插入、删除等操作时，需要满足以下规则，使其保持平衡：

1. 节点颜色规则：每个节点要么是红色，要么是黑色。
2. 根节点规则：根节点是黑色。
3. 红色节点规则：红色节点的子节点必须是黑色。
4. 黑色节点规则：每个黑色节点必须有两个子节点，且它们的黑高度



13、哪些场景应用到了红黑树？<a name ="13"></a>

红黑树具有平衡性和快速查找的特点，因此在很多场景下都被广泛应用。以下是一些常见的场景：

1. C++ STL中的set和map。set是基于红黑树实现的，map也可以选择基于红黑树实现。这些容器的快速查找和插入操作离不开红黑树的平衡性。
2. 数据库索引。数据库中的B+树等索引结构，通常也需要保持平衡性，红黑树也可以作为一种选择。
3. Linux内核调度。Linux内核中的进程调度算法使用了红黑树来维护进程的调度顺序。
4. 计算机网络中的路由表。路由表需要快速查找目标IP地址对应的路由信息，因此也可以使用红黑树作为实现。
5. 资源管理器。一些操作系统的资源管理器，如Windows的NTFS文件系统和Linux的ext4文件系统，使用了红黑树来维护文件的索引信息。
6. 平衡二叉堆。红黑树也可以用来实现平衡二叉堆，用于高效地维护优先级队列。



参考资料：

小林coding

chatGPT

知乎
